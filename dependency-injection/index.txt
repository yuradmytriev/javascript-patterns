In software engineering, dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. 
A dependency is an object that can be used (a service). An injection is the passing of a dependency to a dependent object (a client) that would use it. 
The service is made part of the client's state.[1] Passing the service to the client, rather than allowing a client to build or find the service, 
is the fundamental requirement of the pattern.

/*-------------------------------------------------------*/

В полном соответствии с принципом единственной ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, 
специально предназначенному для этого общему механизму

При настоящем внедрении зависимости объект пассивен и не предпринимает вообще никаких шагов для выяснения зависимостей, 
а предоставляет для этого сеттеры и/или принимает своим конструктором аргументы, посредством которых внедряются зависимости[1].

Внедрение зависимости более гибко, потому что становится легче создавать альтернативные реализации данного типа сервиса, а потом указывать, 
какая именно реализация должна быть использована в, например, конфигурационном файле, без изменений в объектах, которые этот сервис используют. 
Это особенно полезно в юнит-тестировании, потому что вставить реализацию «заглушки» сервиса в тестируемый объект очень просто.

С другой стороны, излишнее использование внедрения зависимостей может сделать приложения более сложными и трудными в сопровождении: 
так как для понимания поведения программы программисту необходимо смотреть не только в исходный код, а еще и в конфигурацию, 
а конфигурация, как правило, невидима для IDE, которые поддерживают анализ ссылок и рефакторинг, если явно не указана поддержка 
фреймворков с внедрениями зависимостей.

/*-------------------------------------------------------------*/

Внедрение зависимостей — это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, 
объекты настраиваются внешними объектами. DI — это альтернатива самонастройке объектов.

Заметьте, что класс MyDao создает экземпляр DataSourceImpl, так как нуждается в источнике данных. Тот факт, 
что MyDao нуждается в реализации DataSource, означает, что он зависит от него. Он не может выполнить свою работу 
без реализации DataSource. Следовательно, MyDao имеет «зависимость» от интерфейса DataSource и от какой-то его реализации. 

/*---------------------------------------------------------------*/

Dependency injection, DI) — процесс предоставления внешней зависимости программному компоненту. 
Является специфичной формой «инверсии управления» (англ. Inversion of control, IoC), 
когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной 
ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму

class DataBaseConnection {
	connect() {
  	return true;
  }
}

class UI {
	showData() {
  	const db = new DataBaseConnection();
    if(db.connect()) {
    	console.log('showData');
    }
  }
}

const ui = new UI();

ui.showData();

->

class DataBaseConnection {
	connect() {
  	return true;
  }
}

class UI {
	constructor(db) {
  	this.db = db;
  }
	showData(db) {
		if(this.db.connect()) {
      console.log('showData');
    }
  }
}

const db = new DataBaseConnection();
const ui = new UI(db);

ui.showData();